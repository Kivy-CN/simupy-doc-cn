
# 第一章 SimuPy 简介

2020年6月11日22:33

SimuPy 是一个对互联动态系统模型（interconnected dynamical system models）进行模拟的框架，提供了一个基于 Python 的开源工具，可以用于基于模型和系统的设计与仿真工作流。动态系统模型（dynamical system models）可被指定为一个对象，具体信息参考 API 文档。模型也可以使用符号表达式（symbolic expressions）来创建，如下面的代码所示：

```Python
from sympy.physics.mechanics import dynamicsymbols #译者注：从sympy导入动态符号
from sympy.tensor.array import Array #译者注：从sympy的张量tensor导入数组 Array
from simupy.systems.symbolic import DynamicalSystem

x = x1, x2, x3 = Array(dynamicsymbols('x1:4'))
u = dynamicsymbols('u')
sys = DynamicalSystem(Array([-x1+x2-x3, -x1*x2-x2+u, -x1+u]), x, u)
```


上面这段代码就自动创建了状态方程（state equations）, 输出方程（output equations）, 以及雅可比方程（jacobians）的可调用函数（callable functions）。默认情况下代码生成器（code generator）使用的是对 `sympy.lambdify`的封装（wrapper）。 你可以更改所用的代码生成器，只需传递系统初始化参数`code_generator` (你选的函数) 和附加的关键词参数字典（译者注：这里的字典是 python的一种数据类型 dictionary） `code_generator_args`。 未来系统（future systems）的默认值可以通过修改模块变量（module variables）来调整。

```Python
import simupy.systems.symbolic
simupy.systems.symbolic.DEFAULT_CODE_GENERATOR = your_code_generator_function #译者注：注意，这里的 'your_code_generator_function' 是让你传递一个函数，这句代码是个示范，不能直接运行的，你要修改成你指定的函数才行，具体如何等后面的文档都翻看完了就知道了
simupy.systems.symbolic.DEFAULT_CODE_GENERATOR_ARGS = {'extra_arg': value}
```

一些帮助类、帮助函数，可以简化模型的创建。例如，线性反馈控制器（linear feedback controller）可以用如下代码定义：

```Python
from simupy.systems import LTISystem
ctrl = LTISystem([[1.73992128, 0.99212953,  -2.98819041]])
```

上面例子中到增益值（gains）来自一个基于原点线性化系统到无穷时域线性二次型调节器（infinite horizon LDR，linear quadratic regulator）。在上面的控制器的基础上，就可以用下面的代码创建一个模块图（block diagram）：

```Python
from simupy.block_diagram import BlockDiagram
BD = BlockDiagram(sys, ctrl)
BD.connect(sys, ctrl) # 将当前状态连接到反馈控制器 ctrl
BD.connect(ctrl, sys) # 将控制输入连接到系统
```

非零维度状态（non-zero dimensional state）系统的初始条件可以定义（默认是适当维度的零值），然后互联系统可以用模块图的模拟方法进行模拟：

```Python
sys.initial_condition = [5, -3, 1]
res = BD.simulate(10)
```

which uses `scipy.integrate.ode` as the default solver for the initial-valued problem. The results are an instance of the SimulationResult class, with array attributes t, x, y, and e, holding time, state, output, and event values for each integrator time step. The first axis indexes the time step. For x, y, and e, the second axis indexes the individual signal components, ordered first by the order each system was added to the block diagram then according to the system state and output specification. The simulation defaults to the dopri5 solver with dense output, but a different integrator_class and integrator_options options can be used as long as it supports a subset of the scipy.integrate.ode API. The default values used for future simulations can be changed following the pattern for the symbolic code generator options.

A number of utilities for constructing and manipulating systems and the simulation results are also included:

    `process_vector_args` and `lambdify_with_vector_args` from `simupy.utils.symbolic` are helpers for code generation using `sympy.lambdify`
    `simupy.utils.callable_from_trajectory` is a simple wrapper for making polynomial spline interpolators using `scipy.interpolate.splprep`
    `simupy.matrices` includes tools for constructing (vector) systems using matrix expressions and re-wrapping the results into matrix form
    `simupy.systems.SystemFromCallable` is a helper for converting a function to a state-less system (typically a controller) to simulate
    `MemorylessSystem` and `LTISystem` are subclasses to more quickly create these types of systems
    `SwitchedSystem` is used to construct systems with discontinuities, defined by `zero-crossings` of the event_equation_function output.

The examples subdirectory includes a number of worked problems. The documentation and docstrings are also available for reference.
Installation

SimuPy is pip installable

```
$ pip install simupy
```

SimuPy has been tested locally against

        Python >= 3.6
        NumPy >= 1.11
        SciPy >= 0.18
        SymPy >= 1.0

but tests on Travis may run with newer versions. Much of the functionality works without SymPy, so installation does not require it. The examples use matplotlib to visualize the results. Testing uses pytest. The documents are built with Sphinx == 1.6.3.
Contributing

    To discuss problems or feature requests, file an issue. For bugs, please include as much information as possible, including operating system, python version, and version of all dependencies.
    To contribute, make a pull request. Contributions should include tests for any new features/bug fixes and follow best practices including PEP8, etc.

